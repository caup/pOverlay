This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T15:30:41.495Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

# Directory Structure
```
CaptureSystem.cpp
CaptureSystem.h
FontManager.h
main.cpp
resource.h
WindowManager.h
```

# Files

## File: CaptureSystem.cpp
```cpp
#include "CaptureSystem.h"

CaptureSystem::CaptureSystem()
    : m_overlayWindow(nullptr)
    , m_screenDC(nullptr)
    , m_memoryDC(nullptr)
    , m_captureBitmap(nullptr)
    , m_bitmapData(nullptr)
    , m_isCapturing(false) {
}

CaptureSystem::~CaptureSystem() {
    StopCapture();
    CleanupCaptureDC();
}

bool CaptureSystem::Initialize(HWND overlayWindow) {
    m_overlayWindow = overlayWindow;
    return SetupCaptureDC();
}

bool CaptureSystem::SetupCaptureDC() {
    // Get screen DC
    m_screenDC = GetDC(nullptr);
    if (!m_screenDC) return false;

    // Create compatible DC
    m_memoryDC = CreateCompatibleDC(m_screenDC);
    if (!m_memoryDC) {
        ReleaseDC(nullptr, m_screenDC);
        m_screenDC = nullptr;
        return false;
    }

    return true;
}

void CaptureSystem::CleanupCaptureDC() {
    if (m_captureBitmap) {
        DeleteObject(m_captureBitmap);
        m_captureBitmap = nullptr;
    }

    if (m_memoryDC) {
        DeleteDC(m_memoryDC);
        m_memoryDC = nullptr;
    }

    if (m_screenDC) {
        ReleaseDC(nullptr, m_screenDC);
        m_screenDC = nullptr;
    }
}

bool CaptureSystem::StartCapture(const RECT& region) {
    if (m_isCapturing) return false;

    m_captureRegion = region;
    int width = region.right - region.left;
    int height = region.bottom - region.top;

    // Create bitmap for capture
    BITMAPINFO bmi = {};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = width;
    bmi.bmiHeader.biHeight = -height; // Top-down
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    m_captureBitmap = CreateDIBSection(m_memoryDC, &bmi, DIB_RGB_COLORS,
        reinterpret_cast<void**>(&m_bitmapData),
        nullptr, 0);
    if (!m_captureBitmap) return false;

    // Start capture thread
    m_isCapturing = true;
    m_captureThread = std::make_unique<std::thread>(&CaptureSystem::CaptureThread, this);

    return true;
}

void CaptureSystem::StopCapture() {
    if (!m_isCapturing) return;

    m_isCapturing = false;
    if (m_captureThread && m_captureThread->joinable()) {
        m_captureThread->join();
    }
}

void CaptureSystem::CaptureThread() {
    auto nextCapture = std::chrono::steady_clock::now();

    while (m_isCapturing) {
        // Process frame
        float xpPercentage = ProcessFrame();

        // TODO: Update UI with new XP percentage

        // Wait for next frame
        nextCapture += FRAME_DURATION;
        std::this_thread::sleep_until(nextCapture);
    }
}

float CaptureSystem::ProcessFrame() {
    // Select bitmap into DC
    HBITMAP oldBitmap = (HBITMAP)SelectObject(m_memoryDC, m_captureBitmap);

    // Capture screen region
    BitBlt(m_memoryDC, 0, 0,
        m_captureRegion.right - m_captureRegion.left,
        m_captureRegion.bottom - m_captureRegion.top,
        m_screenDC,
        m_captureRegion.left, m_captureRegion.top,
        SRCCOPY);

    // Analyze the captured region
    float result = AnalyzeRegion();

    // Convert to percentage string with 2 decimal places
    std::wstringstream ss;
    ss << std::fixed << std::setprecision(2) << result << L"%";
    // Signal main window to update (we'll add this functionality)
    PostMessage(m_overlayWindow, WM_USER_XP_UPDATE, 0,
        reinterpret_cast<LPARAM>(_wcsdup(ss.str().c_str())));

    // Cleanup
    SelectObject(m_memoryDC, oldBitmap);

    return result;
}

bool CaptureSystem::IsFilledPixel(const RGBQUAD& pixel) {
    // Check for XP fill color (#2D67E2)
    const int fillRed = 0x2D;    // 45
    const int fillGreen = 0x67;  // 103
    const int fillBlue = 0xE2;   // 226

    // Allow some tolerance for slight variations
    const int tolerance = 20;

    return abs(pixel.rgbRed - fillRed) <= tolerance &&
        abs(pixel.rgbGreen - fillGreen) <= tolerance &&
        abs(pixel.rgbBlue - fillBlue) <= tolerance;
}

bool CaptureSystem::IsMarkerPixel(const RGBQUAD& pixel) {
    // Check for regular marker color (#99A6C0)
    const int markerRed = 0x99;   // 153
    const int markerGreen = 0xA6; // 166
    const int markerBlue = 0xC0;  // 192

    // Check for filled marker color (#9BB0ED)
    const int filledMarkerRed = 0x9B;   // 155
    const int filledMarkerGreen = 0xB0; // 176
    const int filledMarkerBlue = 0xED;  // 237

    const int tolerance = 12;

    // Check if it's either a regular marker or a filled marker
    bool isRegularMarker = abs(pixel.rgbRed - markerRed) <= tolerance &&
        abs(pixel.rgbGreen - markerGreen) <= tolerance &&
        abs(pixel.rgbBlue - markerBlue) <= tolerance;

    bool isFilledMarker = abs(pixel.rgbRed - filledMarkerRed) <= tolerance &&
        abs(pixel.rgbGreen - filledMarkerGreen) <= tolerance &&
        abs(pixel.rgbBlue - filledMarkerBlue) <= tolerance;

    return isRegularMarker || isFilledMarker;
}

bool CaptureSystem::IsFilledMarkerPixel(const RGBQUAD& pixel) {
    const int filledMarkerRed = 0x9B;   // 155
    const int filledMarkerGreen = 0xB0; // 176
    const int filledMarkerBlue = 0xED;  // 237

    const int tolerance = 12;

    return abs(pixel.rgbRed - filledMarkerRed) <= tolerance &&
        abs(pixel.rgbGreen - filledMarkerGreen) <= tolerance &&
        abs(pixel.rgbBlue - filledMarkerBlue) <= tolerance;
}

bool CaptureSystem::IsVerticalBarSequence(int x, int y) {
    const int verticalBarWidth = 4; // Vertical bars are 4 pixels wide
    const int tolerance = 10; // Tolerance for color variations

    // Check if the next 4 pixels are vertical bar pixels
    for (int i = 0; i < verticalBarWidth; i++) {
        if (x + i >= m_captureRegion.right - m_captureRegion.left) {
            return false; // Out of bounds
        }

        RGBQUAD* pixel = reinterpret_cast<RGBQUAD*>(
            m_bitmapData + (y * (m_captureRegion.right - m_captureRegion.left) + (x + i)) * 4);

        if (!IsMarkerPixel(*pixel)) {
            return false; // Not a vertical bar pixel
        }
    }

    return true; // Found a 4-pixel vertical bar sequence
}

bool CaptureSystem::IsBackgroundPixel(const RGBQUAD& pixel) {
    // Check for background color (#002240)
    const int bgRed = 0x00;   // 0
    const int bgGreen = 0x22; // 34
    const int bgBlue = 0x40;  // 64

    const int tolerance = 8;

    return abs(pixel.rgbRed - bgRed) <= tolerance &&
        abs(pixel.rgbGreen - bgGreen) <= tolerance &&
        abs(pixel.rgbBlue - bgBlue) <= tolerance;
}

float CaptureSystem::AnalyzeRegion() {
    if (!m_bitmapData) return 0.0f;

    const int width = m_captureRegion.right - m_captureRegion.left;
    const int height = m_captureRegion.bottom - m_captureRegion.top;

    if (width <= 0 || height <= 0) return 0.0f;

    // Sample from the middle vertical position of the bar
    const int sampleY = height / 2;

    // Count filled pixels
    int filledPixels = 0;
    int totalPixels = 0;

    // Scan horizontally across the bar
    for (int x = 0; x < width; x++) {
        RGBQUAD* pixel = reinterpret_cast<RGBQUAD*>(
            m_bitmapData + (sampleY * width + x) * 4);

        // Skip if pixel isn't part of the XP bar (i.e., not fill color or background)
        if (!IsFilledPixel(*pixel) && !IsBackgroundPixel(*pixel) && !IsMarkerPixel(*pixel)) {
            continue;
        }

        // Check if this is the start of a marker sequence
        if (IsVerticalBarSequence(x, sampleY)) {
            bool isFilledLeft = false;
            bool isFilledRight = false;

            // Check pixels on both sides of the marker
            if (x > 0) {
                RGBQUAD* pixelLeft = reinterpret_cast<RGBQUAD*>(
                    m_bitmapData + (sampleY * width + (x - 1)) * 4);
                isFilledLeft = IsFilledPixel(*pixelLeft);
            }

            if (x + 4 < width) {
                RGBQUAD* pixelRight = reinterpret_cast<RGBQUAD*>(
                    m_bitmapData + (sampleY * width + (x + 4)) * 4);
                isFilledRight = IsFilledPixel(*pixelRight);
            }

            // Check if the marker itself shows the filled color
            bool isMarkerFilled = false;
            for (int i = 0; i < 4; i++) {
                RGBQUAD* markerPixel = reinterpret_cast<RGBQUAD*>(
                    m_bitmapData + (sampleY * width + (x + i)) * 4);
                if (IsFilledMarkerPixel(*markerPixel)) {
                    isMarkerFilled = true;
                    break;
                }
            }

            // Count marker as filled if either:
            // 1. Both sides are filled
            // 2. The marker itself shows the filled marker color
            if ((isFilledLeft && isFilledRight) || isMarkerFilled) {
                filledPixels += 4;
            }
            totalPixels += 4;
            x += 3; // Skip the rest of the marker
            continue;
        }

        // Count normal pixels
        if (IsFilledPixel(*pixel)) {
            filledPixels++;
        }
        totalPixels++;
    }

    // Calculate percentage
    if (totalPixels > 0) {
        return (filledPixels * 100.0f) / totalPixels;
    }

    return 0.0f;
}
```

## File: CaptureSystem.h
```
#define WM_USER_XP_UPDATE (WM_USER + 1)

#pragma once
#include <windows.h>
#include <memory>
#include <chrono>
#include <thread>
#include <atomic>

class CaptureSystem {
public:
    CaptureSystem();
    ~CaptureSystem();

    // Initialize capture system
    bool Initialize(HWND overlayWindow);

    // Start/Stop capture
    bool StartCapture(const RECT& region);
    void StopCapture();

    // Process one frame and return XP percentage (0-100)
    float ProcessFrame();

private:
    // Capture thread function
    void CaptureThread();

    // Helper functions
    bool SetupCaptureDC();
    void CleanupCaptureDC();
    float AnalyzeRegion();
    bool IsFilledPixel(const RGBQUAD& pixel);
    bool IsMarkerPixel(const RGBQUAD& pixel);
    bool IsFilledMarkerPixel(const RGBQUAD& pixel);
    bool IsBackgroundPixel(const RGBQUAD& pixel);
    bool IsVerticalBarSequence(int x, int y);



    // Members
    HWND m_overlayWindow;
    RECT m_captureRegion;

    // GDI resources
    HDC m_screenDC;
    HDC m_memoryDC;
    HBITMAP m_captureBitmap;
    BYTE* m_bitmapData;

    // Thread control
    std::atomic<bool> m_isCapturing;
    std::unique_ptr<std::thread> m_captureThread;

    // Timing control
    static constexpr int CAPTURE_FPS = 4; // 4 frames per second
    static constexpr auto FRAME_DURATION = std::chrono::milliseconds(1000 / CAPTURE_FPS);
};
```

## File: FontManager.h
```
#pragma once
#include <windows.h>
#include <string>
#include <vector>

class FontManager {
private:
    std::vector<HANDLE> loadedFonts;

public:
    ~FontManager() {
        // Clean up all loaded fonts
        for (HANDLE fontHandle : loadedFonts) {
            RemoveFontMemResourceEx(fontHandle);
        }
    }

    bool LoadFontFromResource(HINSTANCE hInstance, int resourceId) {
        // Load the font resource
        HRSRC fontResource = FindResource(hInstance, MAKEINTRESOURCE(resourceId), RT_FONT);
        if (!fontResource) return false;

        HGLOBAL fontData = LoadResource(hInstance, fontResource);
        if (!fontData) return false;

        void* fontPtr = LockResource(fontData);
        DWORD fontSize = SizeofResource(hInstance, fontResource);

        // Add font to memory
        DWORD numFonts = 0;
        HANDLE fontHandle = AddFontMemResourceEx(
            fontPtr,
            fontSize,
            nullptr,
            &numFonts
        );

        if (fontHandle) {
            loadedFonts.push_back(fontHandle);
            return true;
        }

        return false;
    }
};
```

## File: main.cpp
```cpp
#include <windows.h>
#include <windowsx.h>
#include <dwmapi.h>
#include <vector>
#include <memory>
#include <string>

#include "resource.h"
#include "WindowManager.h"
#include "CaptureSystem.h"
#include "FontManager.h"

#pragma comment(lib, "dwmapi.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")

// Error handling helper
void ShowError(const wchar_t* message) {
    MessageBoxW(nullptr, message, L"Error", MB_ICONEXCLAMATION | MB_OK);
}

// Application state
struct AppState {
    bool isDrawing = false;
    bool isClickthrough = true;
    bool hasSelectedRegion = false;
    POINT startPoint = { 0, 0 };
    POINT endPoint = { 0, 0 };
    RECT selectedRegion = { 0, 0, 0, 0 };

    std::unique_ptr<FontManager> fontManager;

    // Text display members
    POINT textPosition = { 350, 350 };
    std::wstring xpText = L"0.00%";
    bool isDraggingText = false;
    POINT dragOffset = { 0, 0 };

	// Game window members
    std::optional<WindowManager::GameWindow> gameWindow;
    static constexpr UINT_PTR WINDOW_TRACK_TIMER = 1;
    static constexpr DWORD WINDOW_TRACK_INTERVAL = 500; // Check every 500ms

    // Add CaptureSystem
    std::unique_ptr<CaptureSystem> captureSystem;
};

// Global state
std::unique_ptr<AppState> g_state = std::make_unique<AppState>();

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_CREATE: {
        // Register for raw input (keyboard)
        RAWINPUTDEVICE rid = {};
        rid.usUsagePage = 0x01;
        rid.usUsage = 0x06;  // Keyboard
        rid.dwFlags = RIDEV_INPUTSINK;
        rid.hwndTarget = hwnd;

        if (!RegisterRawInputDevices(&rid, 1, sizeof(rid))) {
            ShowError(L"Failed to register raw input devices!");
            return -1;
        }
        return 0;
    }

    case WM_INPUT: {
        UINT size = 0;
        GetRawInputData((HRAWINPUT)lParam, RID_INPUT, nullptr, &size, sizeof(RAWINPUTHEADER));

        std::vector<BYTE> buffer(size);
        if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, buffer.data(), &size, sizeof(RAWINPUTHEADER)) != size) {
            ShowError(L"Failed to get raw input data!");
            return 0;
        }

        RAWINPUT* raw = reinterpret_cast<RAWINPUT*>(buffer.data());
        if (raw->header.dwType == RIM_TYPEKEYBOARD) {
            if (raw->data.keyboard.Message == WM_KEYDOWN) {
                if (raw->data.keyboard.VKey == VK_F7) {
                    g_state->isClickthrough = !g_state->isClickthrough;

                    LONG_PTR exStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
                    if (g_state->isClickthrough) {
                        exStyle |= WS_EX_TRANSPARENT;
                        // Keep text visible but make background fully transparent
                        SetLayeredWindowAttributes(hwnd, RGB(128, 128, 128), 0, LWA_COLORKEY);
                    }
                    else {
                        exStyle &= ~WS_EX_TRANSPARENT;
                        // Semi-transparent background for setup mode
                        SetLayeredWindowAttributes(hwnd, 0, 100, LWA_ALPHA);
                    }
                    SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle);

                    InvalidateRect(hwnd, nullptr, TRUE);
                }
            }
        }
        return 0;
    }

    case WM_USER_XP_UPDATE: {
        // Update XP text
        wchar_t* newText = reinterpret_cast<wchar_t*>(lParam);
        g_state->xpText = newText;
        free(newText);  // Free the duplicated string
        InvalidateRect(hwnd, nullptr, TRUE);
        return 0;
    }

    case WM_LBUTTONDOWN: {
        if (!g_state->isClickthrough) {
            // Check if click is within text bounds
            RECT textRect;
            GetClientRect(hwnd, &textRect);
            HDC hdc = GetDC(hwnd);

            // Try Crimson Text first, fall back to Times New Roman
            HFONT font = CreateFont(24, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Crimson Text");

            if (!font) {
                font = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                    DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                    CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Times New Roman");
            }

            HFONT oldFont = (HFONT)SelectObject(hdc, font);
            DrawText(hdc, g_state->xpText.c_str(), -1, &textRect,
                DT_CALCRECT | DT_SINGLELINE);
            SelectObject(hdc, oldFont);
            DeleteObject(font);
            ReleaseDC(hwnd, hdc);

            textRect.left += g_state->textPosition.x;
            textRect.right += g_state->textPosition.x;
            textRect.top += g_state->textPosition.y;
            textRect.bottom += g_state->textPosition.y;

            POINT clickPoint = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            if (PtInRect(&textRect, clickPoint)) {
                g_state->isDraggingText = true;
                g_state->dragOffset.x = clickPoint.x - g_state->textPosition.x;
                g_state->dragOffset.y = clickPoint.y - g_state->textPosition.y;
                return 0;
            }

            // Start new drawing regardless of existing region
            g_state->isDrawing = true;
            g_state->startPoint.x = GET_X_LPARAM(lParam);
            g_state->startPoint.y = GET_Y_LPARAM(lParam);
            g_state->endPoint = g_state->startPoint;
            SetCapture(hwnd);
        }
        return 0;
    }

    case WM_MOUSEMOVE: {
        if (g_state->isDraggingText) {
            g_state->textPosition.x = GET_X_LPARAM(lParam) - g_state->dragOffset.x;
            g_state->textPosition.y = GET_Y_LPARAM(lParam) - g_state->dragOffset.y;
            InvalidateRect(hwnd, nullptr, TRUE);
            return 0;
        }

        if (g_state->isDrawing) {
            g_state->endPoint.x = GET_X_LPARAM(lParam);
            g_state->endPoint.y = GET_Y_LPARAM(lParam);
            InvalidateRect(hwnd, nullptr, TRUE);
        }
        return 0;
    }

    case WM_LBUTTONUP: {
        if (g_state->isDraggingText) {
            g_state->isDraggingText = false;
            return 0;
        }

        if (g_state->isDrawing) {
            g_state->isDrawing = false;
            ReleaseCapture();

            RECT rect;
            rect.left = min(g_state->startPoint.x, g_state->endPoint.x);
            rect.top = min(g_state->startPoint.y, g_state->endPoint.y);
            rect.right = max(g_state->startPoint.x, g_state->endPoint.x);
            rect.bottom = max(g_state->startPoint.y, g_state->endPoint.y);

            // Only set region if it has size
            if (rect.right - rect.left > 0 && rect.bottom - rect.top > 0) {
                g_state->selectedRegion = rect;
                g_state->hasSelectedRegion = true;

                // Stop any existing capture before starting a new one
                if (g_state->captureSystem) {
                    g_state->captureSystem->StopCapture();
                }
                else {
                    g_state->captureSystem = std::make_unique<CaptureSystem>();
                    if (!g_state->captureSystem->Initialize(hwnd)) {
                        ShowError(L"Failed to initialize capture system!");
                        g_state->captureSystem.reset();
                        return 0;
                    }
                }

                // Start capture with new region
                if (!g_state->captureSystem->StartCapture(rect)) {
                    ShowError(L"Failed to start capture!");
                    g_state->captureSystem.reset();  // Clean up failed capture system
                    g_state->hasSelectedRegion = false;  // Reset region selection state
                }

                InvalidateRect(hwnd, nullptr, TRUE);
            }
        }
        return 0;
    }

    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        // Get client area size
        RECT clientRect;
        GetClientRect(hwnd, &clientRect);
        // Create memory DC for double buffering
        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP memBitmap = CreateCompatibleBitmap(hdc, clientRect.right, clientRect.bottom);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, memBitmap);
        // Fill background with the color we're using as transparent
        HBRUSH bgBrush = CreateSolidBrush(RGB(128, 128, 128));
        FillRect(memDC, &clientRect, bgBrush);
        DeleteObject(bgBrush);

        // Only show rectangles when not in click-through mode
        if (!g_state->isClickthrough) {
            // Draw selected region if exists
            if (g_state->hasSelectedRegion) {
                HBRUSH brush = CreateSolidBrush(RGB(0, 255, 0));  // Green for selected region
                FrameRect(memDC, &g_state->selectedRegion, brush);
                DeleteObject(brush);
            }
            // Draw current rectangle if drawing
            if (g_state->isDrawing) {
                RECT currentRect;
                currentRect.left = min(g_state->startPoint.x, g_state->endPoint.x);
                currentRect.top = min(g_state->startPoint.y, g_state->endPoint.y);
                currentRect.right = max(g_state->startPoint.x, g_state->endPoint.x);
                currentRect.bottom = max(g_state->startPoint.y, g_state->endPoint.y);
                HBRUSH brush = CreateSolidBrush(RGB(255, 0, 0));  // Red for drawing
                FrameRect(memDC, &currentRect, brush);
                DeleteObject(brush);
            }
        }

        // Draw XP text if:
        // 1. We're in setup mode (not click-through), OR
        // 2. We have a selected region AND the game window is focused
        bool shouldDrawText = !g_state->isClickthrough ||
            (g_state->hasSelectedRegion && g_state->gameWindow &&
                GetForegroundWindow() == g_state->gameWindow->handle);
        if (shouldDrawText) {
            // Create and setup font - try Crimson Text first, fall back to Times New Roman
            HFONT font = CreateFont(24, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Crimson Text");

            if (!font) {
                font = CreateFont(20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
                    DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                    CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Times New Roman");
            }
            HFONT oldFont = (HFONT)SelectObject(memDC, font);

            // Setup text color and mode
            SetTextColor(memDC, RGB(255, 255, 255));  // White text
            SetBkMode(memDC, TRANSPARENT);

            // Draw text with outline
            SetTextColor(memDC, RGB(0, 0, 0));  // Black outline
            for (int offsetX = -1; offsetX <= 1; offsetX++) {
                for (int offsetY = -1; offsetY <= 1; offsetY++) {
                    if (offsetX == 0 && offsetY == 0) continue;
                    TextOut(memDC,
                        g_state->textPosition.x + offsetX,
                        g_state->textPosition.y + offsetY,
                        g_state->xpText.c_str(),
                        g_state->xpText.length());
                }
            }

            // Draw main text
            SetTextColor(memDC, RGB(255, 255, 255));  // White text
            TextOut(memDC,
                g_state->textPosition.x,
                g_state->textPosition.y,
                g_state->xpText.c_str(),
                g_state->xpText.length());

            // Cleanup font
            SelectObject(memDC, oldFont);
            DeleteObject(font);
        }

        // Copy memory DC to window
        BitBlt(hdc, 0, 0, clientRect.right, clientRect.bottom, memDC, 0, 0, SRCCOPY);

        // Cleanup
        SelectObject(memDC, oldBitmap);
        DeleteObject(memBitmap);
        DeleteDC(memDC);

        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_TIMER: {
        if (wParam == AppState::WINDOW_TRACK_TIMER && g_state->gameWindow) {
            // Update overlay position to match game window
            if (!WindowManager::RefreshOverlayPosition(hwnd, g_state->gameWindow.value())) {
                // Game window was closed or minimized
                ShowError(L"Lost connection to Pantheon window!");
                DestroyWindow(hwnd);
            }
        }
        return 0;
    }

    case WM_DESTROY: {
        KillTimer(hwnd, AppState::WINDOW_TRACK_TIMER);
        if (g_state->captureSystem) {
            g_state->captureSystem->StopCapture();
        }
        PostQuitMessage(0);
        return 0;
    }

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
}

bool RegisterOverlayClass(HINSTANCE hInstance) {
    WNDCLASSEX wc = {};
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(nullptr, IDC_CROSS);
    wc.lpszClassName = L"OverlayWindow";
    wc.hbrBackground = nullptr;
    wc.hIcon = LoadIcon(nullptr, IDI_APPLICATION);
    wc.hIconSm = LoadIcon(nullptr, IDI_APPLICATION);

    if (!RegisterClassEx(&wc)) {
        ShowError(L"Failed to register window class!");
        return false;
    }
    return true;
}

HWND CreateOverlayWindow(HINSTANCE hInstance, const RECT& bounds) {
    HWND hwnd = CreateWindowEx(
        WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TRANSPARENT,
        L"OverlayWindow",
        L"Game Overlay",
        WS_POPUP,
        bounds.left, bounds.top,
        bounds.right - bounds.left,
        bounds.bottom - bounds.top,
        nullptr, nullptr,
        hInstance,
        nullptr
    );

    if (!hwnd) {
        ShowError(L"Failed to create overlay window!");
        return nullptr;
    }

    // Start with color keying for the background
    SetLayeredWindowAttributes(hwnd, RGB(128, 128, 128), 0, LWA_COLORKEY);

    return hwnd;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    
    if (!RegisterOverlayClass(hInstance)) {
        return 1;
    }

    // Initialize FontManager and load Crimson Text font
    g_state->fontManager = std::make_unique<FontManager>();
    if (!g_state->fontManager->LoadFontFromResource(hInstance, IDR_FONT_CRIMSONTEXT)) {
        ShowError(L"Failed to load Crimson Text font!");
        return 1;
    }

    // Find Pantheon window
    auto gameWindow = WindowManager::FindPantheonWindow();
    if (!gameWindow) {
        ShowError(L"Pantheon window not found!");
        return 1;
    }

    g_state->gameWindow = gameWindow;

    // Create overlay sized to match game window
    HWND hwnd = CreateOverlayWindow(hInstance, gameWindow->bounds);
    if (!hwnd) {
        return 1;
    }

    // Set timer to track window position
    SetTimer(hwnd, AppState::WINDOW_TRACK_TIMER, AppState::WINDOW_TRACK_INTERVAL, nullptr);

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    MSG msg = {};
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return static_cast<int>(msg.wParam);
}
```

## File: resource.h
```
#pragma once
#include <windows.h> // Include necessary header

#define IDR_FONT_CRIMSONTEXT 101
```

## File: WindowManager.h
```
#pragma once
#include <windows.h>
#include <string>
#include <optional>

class WindowManager {
public:
    struct GameWindow {
        HWND handle;
        RECT bounds;
    };

    static std::optional<GameWindow> FindPantheonWindow() {
        // Find window with exact title "Pantheon"
        HWND hwnd = FindWindowW(nullptr, L"Pantheon");
        if (!hwnd || !IsWindow(hwnd) || !IsWindowVisible(hwnd)) {
            return std::nullopt;
        }

        RECT bounds;
        GetWindowRect(hwnd, &bounds);

        // Verify window isn't minimized
        if (bounds.left <= -32000 || bounds.top <= -32000) {
            return std::nullopt;
        }

        return GameWindow{ hwnd, bounds };
    }

    static std::optional<RECT> GetGameWindowBounds(const GameWindow& gameWindow) {
        // Verify window still exists and is valid
        if (!IsWindow(gameWindow.handle)) {
            return std::nullopt;
        }

        RECT bounds;
        GetWindowRect(gameWindow.handle, &bounds);

        // Check if window is minimized
        if (bounds.left <= -32000 || bounds.top <= -32000) {
            return std::nullopt;
        }

        return bounds;
    }

    static void UpdateOverlayPosition(HWND overlayWindow, const RECT& bounds) {
        // Update overlay window position and size to match game window
        SetWindowPos(overlayWindow, HWND_TOPMOST,
            bounds.left, bounds.top,
            bounds.right - bounds.left,
            bounds.bottom - bounds.top,
            SWP_NOACTIVATE | SWP_SHOWWINDOW);
    }

    // Call this periodically to keep overlay aligned with game window
    static bool RefreshOverlayPosition(HWND overlayWindow, GameWindow& gameWindow) {
        if (auto bounds = GetGameWindowBounds(gameWindow)) {
            UpdateOverlayPosition(overlayWindow, bounds.value());
            gameWindow.bounds = bounds.value();
            return true;
        }
        return false;
    }
};
```
